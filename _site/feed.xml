<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-02-26T00:23:51+03:00</updated><id>http://localhost:4000/</id><title type="html">Superfluous Instantiation</title><subtitle>This is fedor1113's personal website. Some programming-related odds and ends, mostly...</subtitle><entry><title type="html">Time Complexity of Common Python Operations</title><link href="http://localhost:4000/blog/2018/10/13/python-time-complexity.html" rel="alternate" type="text/html" title="Time Complexity of Common Python Operations" /><published>2018-10-13T00:00:00+03:00</published><updated>2018-10-13T00:00:00+03:00</updated><id>http://localhost:4000/blog/2018/10/13/python-time-complexity</id><content type="html" xml:base="http://localhost:4000/blog/2018/10/13/python-time-complexity.html">&lt;h1&gt;Time Complexity of Common Python Operations&lt;/h1&gt;
&lt;aside class=&quot;epigraph&quot;&gt;
    &lt;blockquote cite=&quot;&quot;&gt;
        I do not fear the time &lt;br /&gt;
        For .... who knows where the time goes?
    &lt;/blockquote&gt;
    -&lt;cite style=&quot;font-style: normal&quot;&gt;Denny, Sandy. &amp;quot;Who Knows Where the Time Goes?&amp;quot; &lt;i&gt;Unhalfbricking&lt;/i&gt;, Island, 1968.&lt;/cite&gt;
&lt;/aside&gt;
&lt;p&gt;
    So, obviously, there already exist some good resources to help you with the topic. I, however, wish to write here a better, nicer, more comprehensive and understandable all-in-one-place article about time complexity of common &lt;b&gt;Python 3.x&lt;/b&gt; operations. After all, the official article could be more explicit and detailed in places - for ease of use's and obviousness's sake.
&lt;/p&gt;
&lt;figure class=&quot;visible_scroll&quot;&gt;
&lt;figcaption&gt;
    Lists operations
&lt;/figcaption&gt;
&lt;table class=&quot;table visible_scroll&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;
                Operation
            &lt;/th&gt;
            &lt;th&gt;
                Code
            &lt;/th&gt;
            &lt;th&gt;
                Big Oh (worst case)
            &lt;/th&gt;
            &lt;th&gt;
                Extra info of note
            &lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Getting an element by index
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(1)
        &lt;/td&gt;
        &lt;td&gt;
            It &lt;em&gt;is&lt;/em&gt; this data struct. most frequent func., so naturally it is constant time
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Setting an element at a given index to a particular value
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(1)
        &lt;/td&gt;
        &lt;td&gt;
            Pretty straightforward
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Taking a slice
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(b-a) (can actually reach O(N+(b-a)))
        &lt;/td&gt;
        &lt;td&gt;
            For the linear case see &amp;quot;Appending an element to a list&amp;quot; - it is basically the same principle
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Inserting a value into a list
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(N)
        &lt;/td&gt;
        &lt;td&gt;
            Guess when it is at its worst... Yeah, inserting in the beginning is usually not a bright idea
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Popping an item from a list
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# for an element&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# with index k&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(N-k)
        &lt;/td&gt;
        &lt;td&gt;
            Notice how lst.pop() (equivalent to lst.pop(-1)) is O(1), so Python lists actually e.g. double as stacks!
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Clearing a list
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(1)
        &lt;/td&gt;
        &lt;td&gt;
            Deleting values is not hard
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Constructing a list from an iterable
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# for iterable&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# of length N_i&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(N&lt;sub&gt;i&lt;/sub&gt;)
        &lt;/td&gt;
        &lt;td&gt;
            You just go over all of the values.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Copying a list
        &lt;/td&gt;
        &lt;td&gt;
            &lt;code&gt;
                &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
            &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(N&lt;sub&gt;1&lt;/sub&gt;)
        &lt;/td&gt;
        &lt;td&gt;
            Allocating memory...
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Extending a list
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lst2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(N&lt;sub&gt;2&lt;/sub&gt;) (or much worse in rare cases - O(N&lt;sub&gt;1&lt;/sub&gt;+N&lt;sub&gt;2&lt;/sub&gt;))
        &lt;/td&gt;
        &lt;td&gt;
            Depends only on the length of the second list (that is, if it is not &lt;em&gt;way&lt;/em&gt; bigger than the original)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Appending an element to a list
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(1) (sometimes O(len(element)))
        &lt;/td&gt;
        &lt;td&gt;
            &lt;strong&gt;O(1) - for sequences of length less or equal to that of the original list. Objects that can be fit into memory already allocated for the list.&lt;/strong&gt;&lt;br /&gt;
            Other cases are of cource linear...
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Equality check
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst2&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# or lst1 != lst2&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(N)
        &lt;/td&gt;
        &lt;td&gt;

        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Reversing a list
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(N)
        &lt;/td&gt;
        &lt;td&gt;
            Quite obvious again
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Iterating over a list
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# doing smth&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# that takes&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# constant time&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(N)
        &lt;/td&gt;
        &lt;td&gt;
            Yeah, well... :)
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            Sorting a list
        &lt;/td&gt;
        &lt;td&gt;
            &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;/td&gt;
        &lt;td&gt;
            O(N Log N)
        &lt;/td&gt;
        &lt;td&gt;
            So you probably know that it is just a &lt;em&gt;mite&lt;/em&gt; more efficient than &lt;i&gt;timsort&lt;/i&gt; implementation in the sorted() object - by virtue of mutating the original
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/figure&gt;</content><author><name></name></author><category term="python" /><category term="python3" /><category term="complexity" /><category term="time complexity" /><category term="big oh" /><category term="big oh notation" /><category term="programming" /><category term="blog" /><category term="benchmarks" /><summary type="html">Time Complexity of Common Python Operations I do not fear the time For .... who knows where the time goes? -Denny, Sandy. &amp;quot;Who Knows Where the Time Goes?&amp;quot; Unhalfbricking, Island, 1968. So, obviously, there already exist some good resources to help you with the topic. I, however, wish to write here a better, nicer, more comprehensive and understandable all-in-one-place article about time complexity of common Python 3.x operations. After all, the official article could be more explicit and detailed in places - for ease of use's and obviousness's sake. Lists operations Operation Code Big Oh (worst case) Extra info of note Getting an element by index lst[i] O(1) It is this data struct. most frequent func., so naturally it is constant time Setting an element at a given index to a particular value lst[i] = element O(1) Pretty straightforward Taking a slice lst[a:b] O(b-a) (can actually reach O(N+(b-a))) For the linear case see &amp;quot;Appending an element to a list&amp;quot; - it is basically the same principle Inserting a value into a list lst.insert(i, element) O(N) Guess when it is at its worst... Yeah, inserting in the beginning is usually not a bright idea Popping an item from a list lst.pop(k) # for an element # with index k O(N-k) Notice how lst.pop() (equivalent to lst.pop(-1)) is O(1), so Python lists actually e.g. double as stacks! Clearing a list lst.clear() O(1) Deleting values is not hard Constructing a list from an iterable list(iterable) # for iterable # of length N_i O(Ni) You just go over all of the values. Copying a list lst2 = lst1.copy() O(N1) Allocating memory... Extending a list lst1.extend(lst2) O(N2) (or much worse in rare cases - O(N1+N2)) Depends only on the length of the second list (that is, if it is not way bigger than the original) Appending an element to a list lst.append(element) O(1) (sometimes O(len(element))) O(1) - for sequences of length less or equal to that of the original list. Objects that can be fit into memory already allocated for the list. Other cases are of cource linear... Equality check lst1 == lst2 # or lst1 != lst2 O(N)</summary></entry></feed>